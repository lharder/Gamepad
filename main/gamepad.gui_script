

function init( self )
	msg.post( ".", "acquire_input_focus" )

	self.background = gui.get_node( "background" )
	self.joystick = gui.get_node( "joystick" )
	self.buttonA = gui.get_node( "buttonA")
	self.buttonB = gui.get_node( "buttonB")
	self.buttonMenu = gui.get_node( "buttonMenu")

	self.joystick_default_position = gui.get_position( self.joystick )
	self.joystick_start_position = self.joystick_default_position
end


function final( self )
	msg.post( ".", "release_input_focus" )
end


function on_message( self, message_id, message, sender )
	if message_id == hash( "register" ) then
		self.listener = sender
		
	elseif message_id == hash( "unregister" ) then
		self.listener = nil

	elseif message_id == hash( "markerRotation" ) then
		gui.set_rotation( self.background, vmath.vector3( 0, 0, message.degrees ) )
	end
end


local function post_to_listener( self, message_id, message )
	if self.listener then
		msg.post( self.listener, message_id, message or {} )
		-- pprint( message )
	end
end



local function handle_touch( self, touch, touch_index )
	if touch.pressed then
		if gui.pick_node( self.buttonMenu, touch.x, touch.y ) then
			msg.post( "controller:/loader#script", "load", { level = MAIN_MENU } )
		end
		
		-- handle joystick
		if gui.pick_node( self.buttonA, touch.x, touch.y) then
			post_to_listener( self, "buttonA", { released = false, pressed = true } )
			
		elseif gui.pick_node( self.buttonB, touch.x, touch.y) then
			post_to_listener( self, "buttonB", { released = false, pressed = true } )
				
		elseif gui.pick_node( self.joystick, touch.x, touch.y ) then
			-- calibrate: jump joystick to finger on first touch!
			calibrate( self, touch )
			
			gui.cancel_animation( self.joystick, gui.PROP_POSITION )
			self.joystick_pressed = { pos = vmath.vector3( touch.x, touch.y, 0 ), index = touch_index }
		end
		
	elseif touch.released then
		if self.joystick_pressed and self.joystick_pressed.index == touch_index then
			gui.animate( self.joystick, gui.PROP_POSITION, self.joystick_start_position, gui.EASING_OUTQUAD, 0.2, 0, 
				function() 
					-- reset joystick to its original, uncalibrated position after animation is done
					self.joystick_start_position = self.joystick_default_position
					gui.set_position( self.background, self.joystick_default_position )
					gui.set_position( self.joystick, self.joystick_default_position )
				end
			)
			post_to_listener( self, "joystick", { x = 0, y = 0 } )
			self.joystick_pressed = nil

			
		else
			if gui.pick_node( self.buttonA, touch.x, touch.y ) then
				post_to_listener( self, "buttonA", { released = true,  pressed = false } )
				
			elseif gui.pick_node( self.buttonB, touch.x, touch.y ) then
				post_to_listener( self, "buttonB", { released = true,  pressed = false } )
			end
		end
		
	elseif self.joystick_pressed and self.joystick_pressed.index == touch_index then
		local position = vmath.vector3( touch.x, touch.y, 0 )
		local dx = self.joystick_start_position.x - touch.x
		local dy = self.joystick_start_position.y - touch.y
		local radians = math.atan2( dy, dx )
		local cos = math.cos( radians )
		local sin = math.sin( radians )
		local distance = math.sqrt( dx * dx + dy * dy )
		local radius = 70
		if distance > radius then
			position.x = self.joystick_start_position.x - cos * radius
			position.y = self.joystick_start_position.y - sin * radius
			distance = radius
		end
		gui.set_position( self.joystick, position)
		post_to_listener( self, "joystick", { x = -( cos * distance / radius ), y = -( sin * distance / radius ) } )
	end
end


function calibrate( self, touch ) 
	local pos = gui.get_position( self.background );
	pos.x = touch.x
	pos.y = touch.y
	gui.set_position( self.background, pos )

	pos = gui.get_position( self.joystick );
	pos.x = touch.x
	pos.y = touch.y
	gui.set_position( self.joystick, pos )
	self.joystick_start_position = pos
end


function on_input( self, action_id, action )
	if action.touch then
		local ratio_x = action.x / ( action.screen_x or action.x )
		local ratio_y = action.y / ( action.screen_y or action.y )
		
		for i, tp in pairs( action.touch ) do
			handle_touch( self, tp, i )
		end
	else
		handle_touch( self, action, 0 )
	end
end
